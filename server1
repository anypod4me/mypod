import express from 'express';
import axios from 'axios';
import cookieParser from 'cookie-parser';
import FormData from 'form-data';
import sharp from 'sharp';
import dotenv from 'dotenv';
import Stripe from 'stripe';
import { randomUUID } from 'node:crypto';
import path from 'node:path';
import fs from 'node:fs';

dotenv.config();
const app = express();
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '');
const PORT = process.env.PORT || 3000;
const __dirname = path.resolve();

app.use(cookieParser());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Public config for client (safe values only)
app.get('/config.json', (req, res) => {
  res.json({
    stripePk: process.env.STRIPE_PUBLISHABLE_KEY || null,
    freeLimit: 3,
    gaId: process.env.GA_MEASUREMENT_ID || null,
    metaPixelId: process.env.META_PIXEL_ID || null
  });
});

app.use(express.static(path.join(__dirname, 'public')));

const OPENAI_KEY = process.env.OPENAI_API_KEY;
const PRINTFUL_KEY = process.env.PRINTFUL_API_KEY;
const PRINTFUL_BASE = 'https://api.printful.com';
const STORE_ID = process.env.PRINTFUL_STORE_ID || null;
const APP_BASE_URL = process.env.APP_BASE_URL || `http://localhost:${PORT}`;
const FREE_LIMIT = 3;

const TMP_DIR = path.join(__dirname, 'tmp');
if (!fs.existsSync(TMP_DIR)) fs.mkdirSync(TMP_DIR);

// Simple content safety
const BAD_WORDS = [
  /\b(nazi|kkk|lynch|rape|gore|beheading|cp|child\s*sexual|terrorist|bomb\s*making|meth\s*cook)\b/i,
  /\b(hate\s*symbol|explicit\s*nudity|incest)\b/i
];
const TEXTY = /(text|word|letters?|typography|quote|slogan|phrase)/i;
const safePrompt = p => p && !BAD_WORDS.some(rx => rx.test(p));

const getCount = req => {
  const n = parseInt(req.cookies['ap4m_count'] || '0', 10);
  return Number.isFinite(n) ? n : 0;
};
const setCount = (res, n) => {
  res.cookie('ap4m_count', String(n), { httpOnly: false, sameSite: 'Lax', maxAge: 1000*60*60*24*365 });
};

async function generateDalle(prompt) {
  const r = await axios.post(
    'https://api.openai.com/v1/images/generations',
    { model: 'dall-e-3', prompt: prompt.trim(), size: '1024x1024', quality: 'hd', n: 1 },
    { headers: { Authorization: `Bearer ${OPENAI_KEY}` } }
  );
  const b64 = r.data?.data?.[0]?.b64_json;
  if (!b64) throw new Error('No image returned');
  return Buffer.from(b64, 'base64');
}

async function upscaleSquare(buf, overlay) {
  let img = sharp(buf).removeAlpha();
  const meta = await img.metadata();
  const side = Math.max(meta.width || 1024, meta.height || 1024);
  const canvas = await sharp({ create: { width: side, height: side, channels: 3, background: '#ffffff' } })
    .composite([{ input: await img.resize({ fit: 'contain', width: side, height: side }).toBuffer(), gravity: 'center' }])
    .toBuffer();
  let out = await sharp(canvas).resize(4500, 4500, { fit: 'cover' }).toBuffer();

  if (overlay?.text?.trim()) {
    const svg = `<svg width="4500" height="4500" xmlns="http://www.w3.org/2000/svg">
      <style>.t{font-family:Arial,Helvetica,sans-serif;font-weight:700;font-size:${Number(overlay.size||160)}px;}</style>
      <text x="50%" y="${Number(overlay.y||4200)}" text-anchor="middle" class="t" fill="${overlay.color||'#000'}">
        ${String(overlay.text).replace(/</g,'&lt;').replace(/>/g,'&gt;')}
      </text>
    </svg>`;
    out = await sharp(out).composite([{ input: Buffer.from(svg), top: 0, left: 0 }]).toBuffer();
  }
  return out;
}

// Printful client
const pf = axios.create({ baseURL: PRINTFUL_BASE, headers: { Authorization: `Bearer ${PRINTFUL_KEY}` } });

// DTG product list (fallback whitelist)
async function fetchDTGProducts() {
  try {
    const cat = await pf.get('/products');
    const list = cat.data?.result || [];
    const whitelist = (process.env.DTG_PRODUCT_WHITELIST||'').split(',').map(s=>Number(s.trim())).filter(Boolean);
    return list
      .filter(p => {
        const id = Number(p.id || p.product_id || 0);
        const name = (p.name||'').toLowerCase();
        const technique = (p.techniques||p.print_techniques||'').toString().toLowerCase();
        const looksDTG = technique.includes('dtg') || /tee|t-shirt|shirt/.test(name);
        return whitelist.includes(id) || looksDTG;
      })
      .map(p => ({ id: p.id || p.product_id, name: p.name }));
  } catch {
    return [
      { id: 4011, name: 'Bella+Canvas 3001 (DTG) – Unisex Soft Tee' },
      { id: 14,   name: 'Gildan 64000 (DTG) – Softstyle Tee' },
      { id: 63,   name: 'Gildan 5000 (DTG) – Heavy Cotton Tee' },
      { id: 71,   name: 'Gildan 2000 (DTG) – Ultra Cotton Tee' }
    ];
  }
}

async function createPrintfulOrder({ recipient, items, external_id }) {
  const payload = {
    external_id: external_id || randomUUID(),
    recipient,
    store_id: STORE_ID || undefined,
    items,
    shipping: 'STANDARD',
    confirm: true
  };
  const r = await pf.post('/orders', payload);
  return r.data;
}

// Routes
app.get('/api/config', (req,res)=> res.json({ stripePk: process.env.STRIPE_PUBLISHABLE_KEY || null, freeLimit: FREE_LIMIT }));

app.get('/api/dtg-products', async (req, res) => {
  try { res.json({ ok: true, products: await fetchDTGProducts() }); }
  catch (e) { res.status(500).json({ ok: false, error: e.message }); }
});

app.post('/api/generate', async (req, res) => {
  try {
    const { prompt } = req.body || {};
    if (!safePrompt(prompt)) return res.status(400).json({ error: 'Invalid or unsafe prompt.' });
    if (TEXTY.test(prompt)) return res.status(400).json({ error: 'Don’t ask DALL·E to draw words. Use the text overlay option after generation.' });

    const used = getCount(req);
    if (used >= FREE_LIMIT) return res.status(402).json({ error: 'Free limit reached. Please subscribe or buy credits.' });

    const dalle = await generateDalle(prompt);
    const up = await upscaleSquare(dalle);
    const id = randomUUID();
    fs.writeFileSync(path.join(TMP_DIR, `${id}.png`), up);
    setCount(res, used + 1);
    res.json({ id, url: `/tmp/${id}.png` });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'Generation failed.' });
  }
});

app.use('/tmp', express.static(TMP_DIR));

app.post('/api/overlay', async (req, res) => {
  try {
    const { id, text, color = '#000000', size = 160, y = 4200 } = req.body || {};
    if (!id) return res.status(400).json({ error: 'Missing image id' });
    const fp = path.join(TMP_DIR, `${id}.png`);
    if (!fs.existsSync(fp)) return res.status(404).json({ error: 'Image not found' });
    const out = await upscaleSquare(fs.readFileSync(fp), { text, color, size, y });
    fs.writeFileSync(fp, out);
    res.json({ id, url: `/tmp/${id}.png` });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'Overlay failed.' });
  }
});

app.post('/api/checkout', async (req, res) => {
  try {
    const { mode = 'subscription', quantity = 1 } = req.body || {};
    const session = await stripe.checkout.sessions.create({
      mode,
      line_items: [{ price: process.env.STRIPE_PRICE_ID, quantity }],
      success_url: `${APP_BASE_URL}/success.html?sid={CHECKOUT_SESSION_ID}`,
      cancel_url: `${APP_BASE_URL}/cancel.html`,
      allow_promotion_codes: true,
      billing_address_collection: 'required'
    });
    res.json({ url: session.url });
  } catch (e) {
    console.error(e);
    res.status(400).json({ error: e.message });
  }
});

app.post('/api/stripe/webhook', express.raw({ type: 'application/json' }), (req, res) => {
  try {
    const sig = req.headers['stripe-signature'];
    const wh = process.env.STRIPE_WEBHOOK_SECRET;
    let event = null;
    if (wh) event = stripe.webhooks.constructEvent(req.body, sig, wh);
    else event = JSON.parse(req.body);
    if (event.type === 'checkout.session.completed') {
      console.log('Checkout completed:', event.data.object.id);
    }
    res.sendStatus(200);
  } catch (e) {
    console.error('Webhook err', e.message);
    res.sendStatus(400);
  }
});

app.post('/api/order', async (req, res) => {
  try {
    const { id, product_id, size, color, quantity = 1, recipient } = req.body || {};
    if (!id || !product_id || !size || !color || !recipient) return res.status(400).json({ error: 'Missing fields' });

    const imgPath = path.join(TMP_DIR, `${id}.png`);
    if (!fs.existsSync(imgPath)) return res.status(404).json({ error: 'Image not found' });

    const fd = new FormData();
    fd.append('file', fs.createReadStream(imgPath));
    const upload = await axios.post(`${PRINTFUL_BASE}/files`, fd, { headers: { Authorization: `Bearer ${PRINTFUL_KEY}`, ...fd.getHeaders() } });
    const fileId = upload.data?.result?.id;
    if (!fileId) throw new Error('Failed to upload to Printful');

    const items = [{
      variant_id: Number(product_id),
      quantity: Number(quantity||1),
      files: [{ id: fileId, position: 'front' }],
      options: [{ id: 'color', value: color }, { id: 'size', value: size }]
    }];

    const data = await createPrintfulOrder({ recipient, items });
    res.json({ ok: true, order: data });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'Order failed' });
  }
});

app.get('*', (req, res) => res.sendFile(path.join(__dirname, 'public', 'index.html')));
app.listen(PORT, () => console.log(`AnyPOD4Me running on http://localhost:${PORT}`));
